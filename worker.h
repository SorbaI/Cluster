//================
// Данные исполнителя.
//================
#include <stdbool.h>
#include <time.h>
#include <arpa/inet.h>

#define INIT_ANS_SIZE 1024


#ifdef DEBUGTEST
#define DEBUG(...) printf(__VA_ARGS__);
#else
#define DEBUG(...)
#endif

//! Структура для хранения информации о рабочем узле.
typedef struct
{
    //! Дескриптор сокета для подключения к серверу.
    int server_conn_fd;

    //! Адрес сервера для подключения.
    struct sockaddr server_addr;

    //! Максимальное время вычисления (в секундах).
    time_t max_time;

    //! Количество ядер процессора.
    size_t n_cores;

    //! Указатель на функцию, выполняющую задачу.
    void *(*func)(void *);
} INFO_WORKER;

//================
// Интерфейс исполнителя.
//================

/*!
 * \brief Инициализирует структуру INFO_WORKER.
 *
 * \param[out] worker Указатель на структуру INFO_WORKER, которую необходимо инициализировать.
 * \param[in] n_cores Количество ядер процессора, выделенных для выполнения задач.
 * \param[in] max_time Максимальное время вычисления (в секундах).
 * \param[in] addr Строка, содержащая IP-адрес сервера (например, "127.0.0.1").
 * \param[in] port Строка, содержащая номер порта сервера (например, "8080").
 * \param[in] func Указатель на функцию, выполняющую задачу (должна соответствовать сигнатуре `void *(void *)`).
 *
 * \return 0 в случае успеха, отрицательное значение(-1) в случае ошибки.
 *
 * \details Функция инициализирует структуру INFO_WORKER, устанавливая параметры подключения к серверу,
 *          максимальное время вычисления, количество ядер и указатель на функцию задачи.
 */
int init_worker(INFO_WORKER* worker, size_t n_cores, time_t max_time, const char *addr, const char *port, void*(func(void*)));



/*!
 * \brief Запускает взаимодействие с сервером для выполнения задач.
 *
 * \param[in] worker Указатель на структуру INFO_WORKER, содержащую информацию о подключении и параметрах.
 *
 * \return 0 в случае успешного завершения, отрицательное значение в случае ошибки.
 *
 * \details Функция устанавливает соединение с сервером, получает задачи, выполняет их и отправляет результаты.
 */
int worker_start(INFO_WORKER *worker);

//! Закрытие сокета для взаимодействия с сервером.
void worker_close(INFO_WORKER *worker);

/*!
 * \brief Извлекает задачу из буфера.
 *
 * \param[in] buf Указатель на буфер, содержащий задачу и её размер.
 * \param[out] recv Указатель, куда будет записан указатель на начало данных задачи (без размера).
 *
 * \return Размер полученной задачи (в байтах).
 *
 * \details Функция считывает размер задачи из начала буфера и возвращает еги и указатель на начало данных задачи.
*/
size_t parse_task(char *buf, void **recv) {

    size_t recv_size = *((size_t*)buf);
    *recv = buf + sizeof(recv_size);
    return recv_size;
}
/*!
 * \brief Форматирует результат вычисления для отправки.
 *
 * \param[in] size Размер результата (в байтах).
 * \param[in] buf Указатель на буфер, содержащий результат вычисления.
 *
 * \return Указатель на отформатированный буфер для отправки.  Возвращает NULL в случае ошибки.
 *
 * \details Функция подготавливает данные для отправки, добавляя размер данных.
 *          Пользователь должен вызвать эту функцию в функции, выполняющей задачу, и вернуть её результат (указатель) как результат работы функции задачи.
 */
void * format_ans(size_t size, void *buf) {
    void *ret = calloc(size + sizeof(size), 1);
    if(ret == NULL) {
        fprintf(stderr, "[format_ans] : ENOMEM\n");
        return NULL;
    }
    *((size_t*) ret) = size;
    memcpy(ret + sizeof(size),buf,size);
    return ret;
}